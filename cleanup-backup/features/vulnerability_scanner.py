"""
Dependency vulnerability scanner with SBOM generation
"""
import asyncio
import json
import re
import hashlib
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum
import aiohttp
import structlog
from cachetools import TTLCache
import uuid

from src.integrations.gitlab_client import get_gitlab_client

logger = structlog.get_logger(__name__)

class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class PackageEcosystem(Enum):
    """Supported package ecosystems"""
    NPM = "npm"
    PYPI = "pypi"
    MAVEN = "maven"
    NUGET = "nuget"
    RUBYGEMS = "rubygems"
    GO = "go"
    COMPOSER = "composer"
    CARGO = "cargo"

@dataclass
class Vulnerability:
    """Vulnerability information"""
    id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: Optional[float]
    affected_package: str
    affected_versions: List[str]
    fixed_versions: List[str]
    published_date: datetime
    references: List[str]
    exploitability: str  # proof_of_concept, exploit_available, no_known_exploit

@dataclass
class PackageDependency:
    """Package dependency information"""
    name: str
    version: str
    ecosystem: PackageEcosystem
    scope: str  # direct, transitive
    file_path: str
    line_number: Optional[int]
    license: Optional[str]
    hash: Optional[str]

@dataclass
class ScanResult:
    """Vulnerability scan result"""
    scan_id: str
    project_id: int
    commit_sha: Optional[str]
    dependencies: List[PackageDependency]
    vulnerabilities: List[Vulnerability]
    sbom: Dict[str, Any]
    scan_timestamp: datetime
    summary: Dict[str, int]

class DependencyParser:
    """Parser for different dependency file formats"""
    
    def __init__(self):
        self.parsers = {
            'package.json': self._parse_package_json,
            'package-lock.json': self._parse_package_lock,
            'requirements.txt': self._parse_requirements_txt,
            'Pipfile': self._parse_pipfile,
            'poetry.lock': self._parse_poetry_lock,
            'pom.xml': self._parse_pom_xml,
            'build.gradle': self._parse_gradle,
            'go.mod': self._parse_go_mod,
            'Cargo.toml': self._parse_cargo_toml,
            'composer.json': self._parse_composer_json,
            'Gemfile': self._parse_gemfile
        }
    
    async def parse_dependencies(self, file_path: str, content: str) -> List[PackageDependency]:
        """Parse dependencies from file content"""
        filename = file_path.split('/')[-1]
        
        if filename in self.parsers:
            try:
                return await self.parsers[filename](file_path, content)
            except Exception as e:
                logger.error(
                    "Failed to parse dependency file",
                    file_path=file_path,
                    filename=filename,
                    error=str(e)
                )
        
        return []
    
    async def _parse_package_json(self, file_path: str, content: str) -> List[PackageDependency]:
        """Parse NPM package.json"""
        try:
            data = json.loads(content)
            dependencies = []
            
            # Production dependencies
            for name, version in data.get('dependencies', {}).items():
                dependencies.append(PackageDependency(
                    name=name,
                    version=self._clean_version(version),
                    ecosystem=PackageEcosystem.NPM,
                    scope="direct",
                    file_path=file_path,
                    line_number=None,
                    license=None,
                    hash=None
                ))
            
            # Dev dependencies
            for name, version in data.get('devDependencies', {}).items():
                dependencies.append(PackageDependency(
                    name=name,
                    version=self._clean_version(version),
                    ecosystem=PackageEcosystem.NPM,
                    scope="direct",
                    file_path=file_path,
                    line_number=None,
                    license=None,
                    hash=None
                ))
            
            return dependencies
            
        except json.JSONDecodeError:
            return []
    
    async def _parse_requirements_txt(self, file_path: str, content: str) -> List[PackageDependency]:
        """Parse Python requirements.txt"""
        dependencies = []
        
        for line_num, line in enumerate(content.splitlines(), 1):
            line = line.strip()
            if not line or line.startswith('#') or line.startswith('-'):
                continue
            
            # Parse package==version format
            match = re.match(r'^([a-zA-Z0-9_.-]+)([><=!]+)([^;]+)', line)
            if match:
                name, operator, version = match.groups()
                dependencies.append(PackageDependency(
                    name=name.strip(),
                    version=version.strip(),
                    ecosystem=PackageEcosystem.PYPI,
                    scope="direct",
                    file_path=file_path,
                    line_number=line_num,
                    license=None,
                    hash=None
                ))
        
        return dependencies
    
    async def _parse_pom_xml(self, file_path: str, content: str) -> List[PackageDependency]:
        """Parse Maven pom.xml (simplified)"""
        dependencies = []
        
        # Simple regex parsing for dependencies
        dependency_pattern = r'<dependency>.*?<groupId>(.*?)</groupId>.*?<artifactId>(.*?)</artifactId>.*?<version>(.*?)</version>.*?</dependency>'
        
        for match in re.finditer(dependency_pattern, content, re.DOTALL):
            group_id, artifact_id, version = match.groups()
            dependencies.append(PackageDependency(
                name=f"{group_id}:{artifact_id}",
                version=version.strip(),
                ecosystem=PackageEcosystem.MAVEN,
                scope="direct",
                file_path=file_path,
                line_number=None,
                license=None,
                hash=None
            ))
        
        return dependencies
    
    async def _parse_go_mod(self, file_path: str, content: str) -> List[PackageDependency]:
        """Parse Go go.mod"""
        dependencies = []
        
        in_require_block = False
        for line_num, line in enumerate(content.splitlines(), 1):
            line = line.strip()
            
            if line.startswith('require ('):
                in_require_block = True
                continue
            elif line == ')' and in_require_block:
                in_require_block = False
                continue
            
            if in_require_block or line.startswith('require '):
                # Parse "module version" format
                parts = line.replace('require ', '').strip().split()
                if len(parts) >= 2:
                    module = parts[0]
                    version = parts[1]
                    dependencies.append(PackageDependency(
                        name=module,
                        version=version,
                        ecosystem=PackageEcosystem.GO,
                        scope="direct",
                        file_path=file_path,
                        line_number=line_num,
                        license=None,
                        hash=None
                    ))
        
        return dependencies
    
    def _clean_version(self, version: str) -> str:
        """Clean version string"""
        # Remove common prefixes
        version = re.sub(r'^[~^>=<]+', '', version)
        return version.strip()
    
    # Placeholder implementations for other parsers
    async def _parse_package_lock(self, file_path: str, content: str) -> List[PackageDependency]:
        return []  # Would implement detailed lock file parsing
    
    async def _parse_pipfile(self, file_path: str, content: str) -> List[PackageDependency]:
        return []  # Would implement TOML parsing
    
    async def _parse_poetry_lock(self, file_path: str, content: str) -> List[PackageDependency]:
        return []  # Would implement poetry.lock parsing
    
    async def _parse_gradle(self, file_path: str, content: str) -> List[PackageDependency]:
        return []  # Would implement Gradle parsing
    
    async def _parse_cargo_toml(self, file_path: str, content: str) -> List[PackageDependency]:
        return []  # Would implement Cargo.toml parsing
    
    async def _parse_composer_json(self, file_path: str, content: str) -> List[PackageDependency]:
        return []  # Would implement Composer parsing
    
    async def _parse_gemfile(self, file_path: str, content: str) -> List[PackageDependency]:
        return []  # Would implement Gemfile parsing

class VulnerabilityDatabase:
    """Interface to vulnerability databases"""
    
    def __init__(self):
        self.session: Optional[aiohttp.ClientSession] = None
        self.cache = TTLCache(maxsize=10000, ttl=3600)  # 1 hour cache
    
    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create HTTP session"""
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30)
            )
        return self.session
    
    async def query_vulnerabilities(self, dependency: PackageDependency) -> List[Vulnerability]:
        """Query vulnerability databases for a dependency"""
        cache_key = f"{dependency.ecosystem.value}:{dependency.name}:{dependency.version}"
        
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        vulnerabilities = []
        
        # Query multiple sources
        try:
            # OSV Database (Google)
            osv_vulns = await self._query_osv(dependency)
            vulnerabilities.extend(osv_vulns)
            
            # GitHub Advisory Database (would need API key)
            # github_vulns = await self._query_github_advisory(dependency)
            # vulnerabilities.extend(github_vulns)
            
        except Exception as e:
            logger.error(
                "Failed to query vulnerability databases",
                dependency=dependency.name,
                error=str(e)
            )
        
        # Cache results
        self.cache[cache_key] = vulnerabilities
        return vulnerabilities
    
    async def _query_osv(self, dependency: PackageDependency) -> List[Vulnerability]:
        """Query OSV (Open Source Vulnerabilities) database"""
        try:
            session = await self._get_session()
            
            # OSV API query
            query_data = {
                "package": {
                    "name": dependency.name,
                    "ecosystem": self._map_ecosystem_to_osv(dependency.ecosystem)
                },
                "version": dependency.version
            }
            
            async with session.post(
                "https://api.osv.dev/v1/query",
                json=query_data
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    return self._parse_osv_response(data, dependency)
                
        except Exception as e:
            logger.debug("OSV query failed", error=str(e))
        
        return []
    
    def _map_ecosystem_to_osv(self, ecosystem: PackageEcosystem) -> str:
        """Map our ecosystem enum to OSV ecosystem names"""
        mapping = {
            PackageEcosystem.NPM: "npm",
            PackageEcosystem.PYPI: "PyPI",
            PackageEcosystem.MAVEN: "Maven",
            PackageEcosystem.GO: "Go",
            PackageEcosystem.CARGO: "crates.io",
            PackageEcosystem.NUGET: "NuGet",
            PackageEcosystem.RUBYGEMS: "RubyGems",
            PackageEcosystem.COMPOSER: "Packagist"
        }
        return mapping.get(ecosystem, ecosystem.value)
    
    def _parse_osv_response(self, data: Dict, dependency: PackageDependency) -> List[Vulnerability]:
        """Parse OSV API response"""
        vulnerabilities = []
        
        for vuln_data in data.get("vulns", []):
            try:
                # Extract severity
                severity = VulnerabilitySeverity.MEDIUM  # Default
                cvss_score = None
                
                for severity_data in vuln_data.get("severity", []):
                    if severity_data.get("type") == "CVSS_V3":
                        cvss_score = float(severity_data.get("score", 0))
                        if cvss_score >= 9.0:
                            severity = VulnerabilitySeverity.CRITICAL
                        elif cvss_score >= 7.0:
                            severity = VulnerabilitySeverity.HIGH
                        elif cvss_score >= 4.0:
                            severity = VulnerabilitySeverity.MEDIUM
                        else:
                            severity = VulnerabilitySeverity.LOW
                
                # Extract affected/fixed versions
                affected_versions = []
                fixed_versions = []
                
                for affected in vuln_data.get("affected", []):
                    if affected.get("package", {}).get("name") == dependency.name:
                        for range_info in affected.get("ranges", []):
                            for event in range_info.get("events", []):
                                if "introduced" in event:
                                    affected_versions.append(event["introduced"])
                                elif "fixed" in event:
                                    fixed_versions.append(event["fixed"])
                
                vulnerability = Vulnerability(
                    id=vuln_data.get("id", ""),
                    cve_id=self._extract_cve_id(vuln_data),
                    title=vuln_data.get("summary", ""),
                    description=vuln_data.get("details", ""),
                    severity=severity,
                    cvss_score=cvss_score,
                    affected_package=dependency.name,
                    affected_versions=affected_versions,
                    fixed_versions=fixed_versions,
                    published_date=self._parse_date(vuln_data.get("published")),
                    references=self._extract_references(vuln_data),
                    exploitability="unknown"
                )
                
                vulnerabilities.append(vulnerability)
                
            except Exception as e:
                logger.warning("Failed to parse vulnerability", error=str(e))
        
        return vulnerabilities
    
    def _extract_cve_id(self, vuln_data: Dict) -> Optional[str]:
        """Extract CVE ID from vulnerability data"""
        for alias in vuln_data.get("aliases", []):
            if alias.startswith("CVE-"):
                return alias
        return None
    
    def _extract_references(self, vuln_data: Dict) -> List[str]:
        """Extract reference URLs"""
        references = []
        for ref in vuln_data.get("references", []):
            if "url" in ref:
                references.append(ref["url"])
        return references
    
    def _parse_date(self, date_str: Optional[str]) -> datetime:
        """Parse date string"""
        if not date_str:
            return datetime.utcnow()
        
        try:
            # Handle ISO format
            return datetime.fromisoformat(date_str.replace("Z", "+00:00"))
        except:
            return datetime.utcnow()
    
    async def close(self):
        """Close HTTP session"""
        if self.session and not self.session.closed:
            await self.session.close()

class SBOMGenerator:
    """Software Bill of Materials generator"""
    
    def generate_cyclone_dx(self, scan_result: ScanResult) -> Dict[str, Any]:
        """Generate SBOM in CycloneDX format"""
        
        sbom = {
            "bomFormat": "CycloneDX",
            "specVersion": "1.5",
            "serialNumber": f"urn:uuid:{scan_result.scan_id}",
            "version": 1,
            "metadata": {
                "timestamp": scan_result.scan_timestamp.isoformat(),
                "tools": [
                    {
                        "vendor": "GitAIOps",
                        "name": "Vulnerability Scanner",
                        "version": "1.0.0"
                    }
                ],
                "component": {
                    "type": "application",
                    "name": f"Project {scan_result.project_id}",
                    "version": "1.0.0"
                }
            },
            "components": [],
            "vulnerabilities": []
        }
        
        # Add components (dependencies)
        for dep in scan_result.dependencies:
            component = {
                "type": "library",
                "bom-ref": f"{dep.name}@{dep.version}",
                "name": dep.name,
                "version": dep.version,
                "scope": dep.scope,
                "purl": self._generate_purl(dep)
            }
            
            if dep.license:
                component["licenses"] = [{"license": {"name": dep.license}}]
            
            if dep.hash:
                component["hashes"] = [{"alg": "SHA-256", "content": dep.hash}]
            
            sbom["components"].append(component)
        
        # Add vulnerabilities
        for vuln in scan_result.vulnerabilities:
            vuln_entry = {
                "bom-ref": vuln.id,
                "id": vuln.id,
                "source": {
                    "name": "OSV",
                    "url": "https://osv.dev"
                },
                "description": vuln.description,
                "detail": vuln.title,
                "recommendation": f"Upgrade to fixed version: {', '.join(vuln.fixed_versions)}" if vuln.fixed_versions else "No fix available",
                "ratings": [
                    {
                        "source": {"name": "CVSSv3"},
                        "score": vuln.cvss_score or 0.0,
                        "severity": vuln.severity.value.upper()
                    }
                ],
                "affects": [
                    {
                        "ref": f"{vuln.affected_package}@{version}"
                    } for version in vuln.affected_versions
                ]
            }
            
            if vuln.cve_id:
                vuln_entry["id"] = vuln.cve_id
            
            sbom["vulnerabilities"].append(vuln_entry)
        
        return sbom
    
    def _generate_purl(self, dependency: PackageDependency) -> str:
        """Generate Package URL (PURL)"""
        ecosystem_map = {
            PackageEcosystem.NPM: "npm",
            PackageEcosystem.PYPI: "pypi",
            PackageEcosystem.MAVEN: "maven",
            PackageEcosystem.GO: "golang",
            PackageEcosystem.CARGO: "cargo",
            PackageEcosystem.NUGET: "nuget",
            PackageEcosystem.RUBYGEMS: "gem",
            PackageEcosystem.COMPOSER: "composer"
        }
        
        ecosystem = ecosystem_map.get(dependency.ecosystem, dependency.ecosystem.value)
        
        # Handle Maven coordinates
        if dependency.ecosystem == PackageEcosystem.MAVEN and ':' in dependency.name:
            group_id, artifact_id = dependency.name.split(':', 1)
            return f"pkg:maven/{group_id}/{artifact_id}@{dependency.version}"
        
        return f"pkg:{ecosystem}/{dependency.name}@{dependency.version}"

class VulnerabilityScanner:
    """Main vulnerability scanner"""
    
    def __init__(self):
        self.gitlab_client = get_gitlab_client()
        self.dependency_parser = DependencyParser()
        self.vuln_db = VulnerabilityDatabase()
        self.sbom_generator = SBOMGenerator()
        self.scan_cache = TTLCache(maxsize=100, ttl=1800)  # 30 min cache
    
    async def scan_project(
        self, 
        project_id: int, 
        commit_sha: Optional[str] = None
    ) -> ScanResult:
        """Scan project for vulnerabilities"""
        
        cache_key = f"scan_{project_id}_{commit_sha}"
        if cache_key in self.scan_cache:
            return self.scan_cache[cache_key]
        
        scan_id = str(uuid.uuid4())
        
        logger.info(
            "Starting vulnerability scan",
            scan_id=scan_id,
            project_id=project_id,
            commit_sha=commit_sha
        )
        
        try:
            # Find dependency files
            dependency_files = await self._find_dependency_files(project_id, commit_sha)
            
            # Parse dependencies
            all_dependencies = []
            for file_path, content in dependency_files.items():
                deps = await self.dependency_parser.parse_dependencies(file_path, content)
                all_dependencies.extend(deps)
            
            # Scan for vulnerabilities
            all_vulnerabilities = []
            for dep in all_dependencies:
                vulns = await self.vuln_db.query_vulnerabilities(dep)
                all_vulnerabilities.extend(vulns)
            
            # Generate summary
            summary = self._generate_summary(all_dependencies, all_vulnerabilities)
            
            # Create scan result
            scan_result = ScanResult(
                scan_id=scan_id,
                project_id=project_id,
                commit_sha=commit_sha,
                dependencies=all_dependencies,
                vulnerabilities=all_vulnerabilities,
                sbom={},  # Will be generated
                scan_timestamp=datetime.utcnow(),
                summary=summary
            )
            
            # Generate SBOM
            scan_result.sbom = self.sbom_generator.generate_cyclone_dx(scan_result)
            
            # Cache result
            self.scan_cache[cache_key] = scan_result
            
            logger.info(
                "Vulnerability scan completed",
                scan_id=scan_id,
                project_id=project_id,
                dependencies_count=len(all_dependencies),
                vulnerabilities_count=len(all_vulnerabilities),
                critical_vulns=summary.get("critical", 0),
                high_vulns=summary.get("high", 0)
            )
            
            return scan_result
            
        except Exception as e:
            logger.error(
                "Vulnerability scan failed",
                scan_id=scan_id,
                project_id=project_id,
                error=str(e),
                exc_info=True
            )
            raise
    
    async def _find_dependency_files(
        self, 
        project_id: int, 
        commit_sha: Optional[str] = None
    ) -> Dict[str, str]:
        """Find and fetch dependency files from repository"""
        
        dependency_files = {}
        ref = commit_sha or "main"
        
        # Known dependency file patterns
        target_files = [
            'package.json', 'package-lock.json',
            'requirements.txt', 'Pipfile', 'poetry.lock',
            'pom.xml', 'build.gradle',
            'go.mod', 'go.sum',
            'Cargo.toml', 'Cargo.lock',
            'composer.json', 'composer.lock',
            'Gemfile', 'Gemfile.lock'
        ]
        
        try:
            # Get repository tree
            tree = await self.gitlab_client.get_project_repository_tree(
                project_id=project_id,
                ref=ref
            )
            
            # Find dependency files
            for item in tree:
                if item.get("type") == "blob" and item.get("name") in target_files:
                    file_path = item.get("path", item.get("name"))
                    
                    try:
                        content = await self.gitlab_client.get_file_content(
                            project_id=project_id,
                            file_path=file_path,
                            ref=ref
                        )
                        
                        if content:
                            dependency_files[file_path] = content
                            
                    except Exception as e:
                        logger.warning(
                            "Failed to fetch dependency file",
                            file_path=file_path,
                            error=str(e)
                        )
                        
        except Exception as e:
            logger.error(
                "Failed to scan repository tree",
                project_id=project_id,
                error=str(e)
            )
        
        return dependency_files
    
    def _generate_summary(
        self, 
        dependencies: List[PackageDependency], 
        vulnerabilities: List[Vulnerability]
    ) -> Dict[str, int]:
        """Generate scan summary statistics"""
        
        summary = {
            "total_dependencies": len(dependencies),
            "direct_dependencies": len([d for d in dependencies if d.scope == "direct"]),
            "transitive_dependencies": len([d for d in dependencies if d.scope == "transitive"]),
            "total_vulnerabilities": len(vulnerabilities),
            "critical": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]),
            "high": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]),
            "medium": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM]),
            "low": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.LOW]),
            "info": len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.INFO])
        }
        
        # Count by ecosystem
        ecosystems = {}
        for dep in dependencies:
            ecosystem = dep.ecosystem.value
            ecosystems[ecosystem] = ecosystems.get(ecosystem, 0) + 1
        
        summary["ecosystems"] = ecosystems
        
        return summary
    
    async def close(self):
        """Close scanner resources"""
        await self.vuln_db.close()

# Global instance
_vulnerability_scanner: Optional[VulnerabilityScanner] = None

def get_vulnerability_scanner() -> VulnerabilityScanner:
    """Get or create vulnerability scanner instance"""
    global _vulnerability_scanner
    if _vulnerability_scanner is None:
        _vulnerability_scanner = VulnerabilityScanner()
    return _vulnerability_scanner